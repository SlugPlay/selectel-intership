# Тестовое задание по направлению «Системное администрирование»

## Задание 1. Анализ access.log

```bash
awk '$1!="" {ip=$1; size=$10; result[ip]+=size} END {for(ip in result) print result[ip] " size for " ip}' access.log

```

Отсортированный лог-файл можно посмотреть тут: [./task-1-logs/result.log](./task-1-logs/result.log)

---

## Задание 2. ESTABLISHED TCP соединения

```bash
lsof -i TCP | grep "ESTABLISHED"

```

---

## Задание 3. Анализ мониторинга

#### Описание скриншота мониторинга

**MySQL Connections:**
- В 12:59 число подключений к базе данных резко возрастает до Max Used Connections
- В 13:05 число подключений упирается в потолок Max Connections
Итог: после 13:05 полностью перестала принимать новые подключения.

**MySQL Questions:**
- В 12:59 число выполненных запросов начало резко падать
- В 13:05 число выполненных запросов стало равно нулю.
Итог: произошёл наплыв новых подключений, а следственно запросов и все они требовали каких-либо ресурсов. Запросы стали конкурировать друг с другом, снижая производительнось БД до минимума, и следствием этого стал полный паралич системы.

**MySQL Client Thread Activity:**
- В 12:59-13:05 возрастает количество подключённых потоков, соразмерно подключениям к БД до 3 тыс. потоков.
- 13:00-13:05 все Connected потоки были в состоянии Running, поэтому число Running Threads достигло 3 тыс.
Итог: всё то возрастающие количество потоков было в состоянии Running, а значит они пытались выполнить свои запросы и бесконечно ждали своей очереди, накапливая затор из поток всё больше и больше.

**MySQL Thread Cache:**
- В 12:59 потребность в закэшированных потоках резко возросла
- В 13:00 закэшированные потоки плностью закончились
Итог: после 13:00 MySQL открытие новых потокв не из кэша начало требовать дополнительных расходов производительности, что ещё усугубило ситуацию. 


#### Ответ на задание
**Причина недоступности** - столпотвроение запросов из-за внутренних блокировок ресурсов (таблиц и т.д.). Причиной этого может быть множество вещей, начиная от неправильного и медленного запроса полученного БД, заканчивая внутренними механизмами БД по очистке и т.д.

**Время отказа** - 13:05. В это время был достигнут лимит по подключениям, производительность запросов упала до нуля, а все потоки стояли в ожидании своего обслуживания.


---

## Задание 4. Оптимизация Dockerfile

#### Первоначальный Dockerfile
```Dockerfile
# Большой тяжёловесный образ. Не указана конкретная версия
FROM ubuntu:latest

# Эта инструкция более не поддерживается, подобные операции делаются через "LABEL"
MAINTAINER MyCompany 

COPY . /var/www/html

# Отдельный слой для обновления системы, стоит объеденить его вместе с install nginx
RUN apt-get update -y

# Не следует брать большой образ ubuntu только ради nginx, вместо этого можно взять готовый образ nginx:1.29.0 
RUN apt-get install -y nginx

CMD ["nginx", "-g", "daemon off;"]
```


#### Итоговый Dockerfiel
```Dockerfile
FROM nginx:1.29.0
LABEL maintainer="MyCompany"

COPY . /var/www/html

# Инструкция запуска nginx уже встроена в образ nginx:1.29.0, поэтому она нам не требуется
# CMD ["nginx", "-g", "daemon off;"]
```

---

## Задание 5. Диагностика проблемы с Nginx

#### Начальные действия

1. Убедиться что проект действительно недоступен
2. Обратиться к системе мониторинга, если таковая имеется.

#### Восстановление доступа к веб-сайту
- Первая же мысль - это взять веб-сайт и временно перенести на другой узел, поставить другой веб-сервер и убедиться в сетевой связности.
- Если проект хорошо задокументирован, то переразвернуть его в другом месте будет намного быстрее, чем искать причину сбоя.
- Если же проект развёрнут на нескольких узлах одновременно, то нужно вывести проблемный узел из ротации.


#### Диагностирование проблемы
1. Просмотр системных логов nginx через `journalctl`
2. Просмотр логов самого nginx - `/var/log`
3. Проверка на уровне сетевых проблем: слушает ли nginx порты, не мешает ли траффику firewall, доступен ли веб-сайт с самого узла.
4. Проверка корректности конфигурации веб-сервера - `nginx -t`
5. Проверка доступности системных ресурсов для nginx (память, CPU)

*Выполнив данные шаги мы сможем получить больше информации для выявления проблемы падения nginx. Далее необходимо отталкиваться уже от полученных результатов.*



---

## Задание 6. Развертывание в Kubernetes

#### Шаги развёртывания
**0.** Выбрать образ нашего приложения и протегировать его конкретной версией: `docker tag ...:1.0.0` .
**1.** [00-namespace.yml](./task-6-k8s/00-namespace.yml) - разворачивается отдельный неймспейс для приложения.
**2.** [01-deployment.yml](./task-6-k8s/01-deployment.yml) - основной манифест нашего приложения.
**3.** [02-service.yml](./task-6-k8s/02-service.yml) - сервис для доступа к нашему приложению через LoadBalancer, так как о наличии Ingress Contrtoller мы не знаем.
**4.** [03-hpa.yml](./task-6-k8s/03-hpa.yml) - манифест настройки автоскейлинга нашего приложения.
**5.** [04-pdb.yml](./task-6-k8s/04-pdb.yml) - механизм устойчивости нашего приложения, минимальное доступное количество подов будет равно 2. 


---

## Задание 7. Инцидент

**1. Сбор информации от заказчика**
Первым делом необходимо тактично попросить заказчика предоставить больше информации об инциденте. Расспросить с какой ошибкой он столкнулся, в какой части приложение и так далее.

**2. Удостовериться в инциденте**
После нужно удостовериться в том, что проблема действительно существует. Проверяем проект и находим проявления данной проблемы.

**3. Создание сводки для команды реагирования**
Быстро подготовить сводку по инциденту и направить её в команду быстрого реагирования.

**4. Помощь в поиске проблемы**
Предложить свою помощь в решении инцидента, если я обладаю необходимой информацией по проекту.

**5. Поддержание контакта с заказчиком**
- Уведомить заказчика, когда проблема будет найдена и обозначить сроки решения проблемы
- Уведомить заказчика, когда проблема будет решена и попросить убедиться, что проект доступен и функционирует.
